<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whack-a-Robot</title>
    <!-- Favicons -->
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="shortcut icon" href="favicon.svg" type="image/svg+xml">
    <!-- Apple Touch Icon for iOS devices -->
    <link rel="apple-touch-icon" href="favicon.svg">
    <!-- For Android Chrome -->
    <meta name="theme-color" content="#0a0b0e">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
    :root {
        --bg-primary: #0a0b0e;
        --bg-secondary: #13151a;
        --bg-tertiary: #1c1f26;
        --accent-primary: #ff3a3a; /* Bright red */
        --accent-secondary: #ffcc00; /* Yellow */
        --accent-tertiary: #ff7b61; /* Orange-red */
        --text-primary: #ffffff;
        --text-secondary: #a1a1aa;
        --success: #00d395;
        --warning: #ffb800;
        --error: #ff5252;
    }
    
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: 'Inter', sans-serif;
    }

    body {
        background-color: var(--bg-primary);
        color: var(--text-primary);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        overflow: hidden;
        position: relative;
    }

    body::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
            radial-gradient(circle at 20% 30%, rgba(255, 58, 58, 0.1) 0%, transparent 20%),
            radial-gradient(circle at 80% 70%, rgba(255, 204, 0, 0.1) 0%, transparent 20%);
        z-index: -1;
    }

    .game-container {
        width: 100%;
        max-width: 800px;
        padding: 30px;
        background-color: var(--bg-secondary);
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.05);
        position: relative;
        overflow: hidden;
    }

    .game-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
    }

    .header {
        display: flex;
        flex-direction: column;
        margin-bottom: 30px;
    }

    h1 {
        font-family: 'Space Grotesk', sans-serif;
        color: var(--text-primary);
        margin-bottom: 20px;
        width: 100%;
        text-align: center;
        font-size: 2.5rem;
        letter-spacing: -0.5px;
        font-weight: 700;
    }

    .timer-container {
        margin-bottom: 20px;
        text-align: center;
    }

    .timer-display {
        background: linear-gradient(to bottom, var(--bg-tertiary), rgba(255, 204, 0, 0.1));
        border: 2px solid rgba(255, 204, 0, 0.3);
        border-radius: 16px;
        padding: 15px 30px;
        display: inline-block;
        position: relative;
        overflow: hidden;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .timer-display::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(90deg, var(--accent-secondary), transparent);
    }

    .timer-label {
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--accent-secondary);
        margin-bottom: 5px;
        font-weight: 600;
    }

    .timer-value {
        font-size: 3.5rem;
        font-weight: 700;
        font-family: 'Space Grotesk', sans-serif;
        color: var(--accent-secondary);
        text-shadow: 0 0 15px rgba(255, 204, 0, 0.3);
        line-height: 1;
    }

    .stats-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
        margin-bottom: 20px;
    }

    .stat-card {
        background-color: var(--bg-tertiary);
        border-radius: 12px;
        padding: 15px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.05);
        position: relative;
        overflow: hidden;
    }

    .stat-card::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 2px;
    }

    .score-container::after {
        background: linear-gradient(90deg, var(--accent-primary), transparent);
    }

    .time-container {
        grid-column: span 2;
        background: linear-gradient(to bottom, var(--bg-tertiary), rgba(255, 204, 0, 0.1));
        border: 1px solid rgba(255, 204, 0, 0.2);
    }

    .time-container .stat-value {
        font-size: 2.5rem;
        color: var(--accent-secondary);
        text-shadow: 0 0 10px rgba(255, 204, 0, 0.3);
    }

    .time-container .stat-label {
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--accent-secondary);
        opacity: 0.8;
    }

    .time-container::after {
        background: linear-gradient(90deg, var(--accent-secondary), transparent);
        height: 3px;
    }

    .streak-container::after {
        background: linear-gradient(90deg, var(--accent-tertiary), transparent);
    }

    .stat-label {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--text-secondary);
        margin-bottom: 5px;
        font-weight: 500;
    }

    .stat-value {
        font-size: 1.8rem;
        font-weight: 700;
        font-family: 'Space Grotesk', sans-serif;
    }

    .score-container .stat-value {
        color: var(--accent-primary);
    }

    .streak-container .stat-value {
        color: var(--accent-tertiary);
    }

    #start-button {
        padding: 14px 28px;
        background-color: var(--accent-primary);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        margin: 0 auto;
        display: block;
        position: relative;
        overflow: hidden;
        letter-spacing: 0.5px;
    }

    #start-button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: 0.5s;
    }

    #start-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(255, 58, 58, 0.4);
    }

    #start-button:hover::before {
        left: 100%;
    }

    #start-button:disabled {
        background-color: rgba(255, 58, 58, 0.5);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
    }

    .game-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 20px;
        margin-bottom: 30px;
        transition: all 0.5s ease;
        position: relative;
        perspective: 1000px;
        transform-style: preserve-3d;
        transform: perspective(1000px) rotateX(5deg);
    }

    .hole {
        position: relative;
        height: 120px;
        background-color: var(--bg-tertiary);
        border-radius: 12px;
        overflow: hidden;
        display: flex;
        justify-content: center;
        box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.3), 0 5px 15px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
        border: 1px solid rgba(255, 255, 255, 0.05);
        transform-style: preserve-3d;
    }

    .hole::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 30%;
        background: linear-gradient(to top, rgba(0, 0, 0, 0.5), transparent);
        pointer-events: none;
    }
    
    .hole::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at center 70%, rgba(0, 0, 0, 0.4), transparent 70%);
        pointer-events: none;
        z-index: 1;
    }

    .robot {
        position: absolute;
        bottom: -100%;
        width: 70px;
        height: 70px;
        background: linear-gradient(135deg, #c0c0c0, #e8e8e8, #a9a9a9); /* Silver metallic gradient */
        border-radius: 12px;
        transition: bottom 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        display: flex;
        justify-content: center;
        align-items: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.5);
        border: 2px solid #707070; /* Steel border */
        overflow: hidden;
        transform-style: preserve-3d;
        perspective: 500px;
    }

    /* Robot head */
    .robot .head {
        position: absolute;
        width: 45px;
        height: 35px;
        background: linear-gradient(to bottom, #e8e8e8, #c0c0c0);
        border-radius: 10px;
        top: 5px;
        border: 1px solid #707070;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        transform: translateZ(8px);
        overflow: hidden;
    }
    
    /* Robot face */
    .robot .face {
        position: absolute;
        width: 41px;
        height: 25px;
        background: linear-gradient(to bottom, #202020, #404040);
        border-radius: 5px;
        top: 5px;
        left: 50%;
        transform: translateX(-50%) translateZ(1px);
        border: 1px solid #606060;
        overflow: hidden;
    }
    
    /* Robot eyes */
    .robot .eyes {
        position: absolute;
        width: 100%;
        height: 12px;
        top: 5px;
        left: 0;
        display: flex;
        justify-content: space-around;
        align-items: center;
    }
    
    .robot .eye {
        width: 10px;
        height: 10px;
        background-color: #ff3a3a; /* Red eye */
        border-radius: 50%;
        box-shadow: 0 0 8px rgba(255, 58, 58, 0.7);
        animation: eye-blink 3s infinite;
        transform-origin: center;
    }
    
    /* New blink animation for the eyes */
    @keyframes eye-blink {
        0%, 45%, 55%, 100% { 
            opacity: 1;
            transform: scaleY(1);
        }
        50% { 
            opacity: 0.7;
            transform: scaleY(0.1);
        }
    }
    
    /* Robot mouth */
    .robot .mouth {
        position: absolute;
        width: 25px;
        height: 4px;
        background: linear-gradient(to bottom, #909090, #707070);
        border-radius: 3px;
        bottom: 5px;
        left: 50%;
        transform: translateX(-50%);
    }
    
    /* Robot body */
    .robot .body {
        position: absolute;
        width: 36px;
        height: 22px;
        background: linear-gradient(to bottom, #b0b0b0, #909090);
        border-radius: 5px;
        top: 40px;
        border: 1px solid #707070;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        transform: translateZ(6px);
    }
    
    /* Robot antenna */
    .robot .antenna {
        position: absolute;
        width: 2px;
        height: 8px;
        background: #707070;
        top: -8px;
        left: 50%;
        transform: translateX(-50%) translateZ(9px);
    }
    
    .robot .antenna::after {
        content: '';
        position: absolute;
        width: 4px;
        height: 4px;
        background: #ff3a3a;
        border-radius: 50%;
        top: -4px;
        left: 50%;
        transform: translateX(-50%);
        box-shadow: 0 0 5px rgba(255, 58, 58, 0.5);
        animation: blink 2s infinite alternate;
    }
    
    /* Simplify the gear positions to avoid covering the face */
    .robot .gear-1 {
        width: 15px;
        height: 15px;
        top: 5px;
        right: 2px;
        animation: rotate 10s linear infinite;
    }
    
    .robot .gear-2 {
        width: 12px;
        height: 12px;
        bottom: 8px;
        left: 2px;
        animation: rotate 7s linear infinite reverse;
    }
    
    .robot .pipe {
        position: absolute;
        width: 6px;
        height: 12px;
        background: linear-gradient(90deg, #707070, #909090);
        top: 10px;
        right: 3px;
        border-radius: 3px;
        border: 1px solid #a0a0a0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        transform: translateZ(7px);
        z-index: 3;
    }
    
    .robot .pipe-steam {
        position: absolute;
        width: 8px;
        height: 8px;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 50%;
        top: 0;
        right: 3px;
        filter: blur(2px);
        opacity: 0;
        animation: steam 2s infinite;
        transform: translateZ(10px);
        z-index: 7;
    }
    
    /* Adjust bolt positions to avoid covering the face */
    .robot .bolt-1 {
        top: 8px;
        left: 3px;
    }
    
    .robot .bolt-2 {
        top: 8px;
        right: 3px;
    }
    
    .robot .bolt-3 {
        bottom: 8px;
        left: 3px;
    }
    
    .robot .bolt-4 {
        bottom: 8px;
        right: 3px;
    }
    
    /* Whacked state adjustments */
    .robot.whacked .eye {
        background-color: #333; /* Eyes power down */
        box-shadow: 0 0 0 rgba(0, 0, 0, 0);
        animation: none;
    }
    
    .robot.whacked .mouth {
        height: 3px;
        width: 20px;
        transform: translateX(-50%) rotate(15deg);
    }

    /* Dent effect when whacked */
    .robot.whacked .dent {
        position: absolute;
        width: 20px;
        height: 20px;
        background: radial-gradient(circle at center, rgba(0,0,0,0.6) 0%, transparent 70%);
        border-radius: 50%;
        top: 15px;
        left: 50%;
        transform: translate(-50%, 0);
        opacity: 0.8;
        z-index: 10;
    }

    /* Metallic texture overlay */
    .robot .metal-texture {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h40v40H0V0zm40 40h-1.5v-1.5H40V40zm-3 0h-1.5v-1.5H37V40zm-3 0h-1.5v-1.5H34V40zm-3 0h-1.5v-1.5H31V40zm-3 0h-1.5v-1.5H28V40zm-3 0h-1.5v-1.5H25V40zm-3 0h-1.5v-1.5H22V40zm-3 0h-1.5v-1.5H19V40zm-3 0h-1.5v-1.5H16V40zm-3 0h-1.5v-1.5H13V40zm-3 0h-1.5v-1.5H10V40zm-3 0H5.5v-1.5H7V40zm-3 0H2.5v-1.5H4V40zm-1.5-3H1v-1.5h1.5V37zm0-3H1v-1.5h1.5V34zm0-3H1v-1.5h1.5V31zm0-3H1v-1.5h1.5V28zm0-3H1v-1.5h1.5V25zm0-3H1v-1.5h1.5V22zm0-3H1v-1.5h1.5V19zm0-3H1v-1.5h1.5V16zm0-3H1V8.5h1.5V10zm0-3H1V5.5h1.5V7zm0-3H1V2.5h1.5V4zm3-1.5H5.5V1H7v1.5zm3 0H8.5V1H10v1.5zm3 0h-1.5V1H13v1.5zm3 0h-1.5V1H16v1.5zm3 0h-1.5V1H19v1.5zm3 0h-1.5V1H22v1.5zm3 0h-1.5V1H25v1.5zm3 0h-1.5V1H28v1.5zm3 0h-1.5V1H31v1.5zm3 0h-1.5V1H34v1.5zm3 0h-1.5V1H37v1.5zm3 0h-1.5V1H40v1.5zm0 3h-1.5V5.5H40V7zm0 3h-1.5V8.5H40V10zm0 3h-1.5v-1.5H40V13zm0 3h-1.5v-1.5H40V16zm0 3h-1.5v-1.5H40V19zm0 3h-1.5v-1.5H40V22zm0 3h-1.5v-1.5H40V25zm0 3h-1.5v-1.5H40V28zm0 3h-1.5v-1.5H40V31zm0 3h-1.5v-1.5H40V34zm0 3h-1.5v-1.5H40V37z' fill='%23ffffff' fill-opacity='0.05' fill-rule='evenodd'/%3E%3C/svg%3E");
        border-radius: 10px;
        opacity: 0.7;
        pointer-events: none;
        z-index: 5;
    }
    
    /* Reflective highlight */
    .robot .highlight {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, 
                                      rgba(255,255,255,0.4) 0%, 
                                      rgba(255,255,255,0) 30%, 
                                      rgba(255,255,255,0) 60%, 
                                      rgba(255,255,255,0.3) 100%);
        border-radius: 10px;
        opacity: 0.7;
        pointer-events: none;
        animation: shift-highlight 3s infinite alternate;
        z-index: 6;
    }
    
    /* Steampunk gear elements */
    .robot .gear {
        position: absolute;
        border-radius: 50%;
        background: linear-gradient(135deg, #a0a0a0, #808080); /* Silver gear gradient */
        border: 2px solid #505050;
        display: flex;
        justify-content: center;
        align-items: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(255, 255, 255, 0.5);
        transform: translateZ(6px);
        z-index: 4;
    }
    
    .robot .gear-1 {
        width: 15px;
        height: 15px;
        top: 5px;
        right: 5px;
        animation: rotate 10s linear infinite;
    }
    
    .robot .gear-2 {
        width: 12px;
        height: 12px;
        bottom: 10px;
        left: 5px;
        animation: rotate 7s linear infinite reverse;
    }
    
    .robot .pipe {
        position: absolute;
        width: 6px;
        height: 12px;
        background: linear-gradient(90deg, #707070, #909090);
        top: 15px;
        right: 8px;
        border-radius: 3px;
        border: 1px solid #a0a0a0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        transform: translateZ(7px);
        z-index: 4;
    }
    
    .robot .pipe-steam {
        position: absolute;
        width: 8px;
        height: 8px;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 50%;
        top: 5px;
        right: 8px;
        filter: blur(2px);
        opacity: 0;
        animation: steam 2s infinite;
        transform: translateZ(10px);
        z-index: 7;
    }
    
    .robot .bolt {
        position: absolute;
        width: 4px;
        height: 4px;
        background: #a0a0a0;
        border-radius: 50%;
        border: 1px solid #505050;
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5);
        transform: translateZ(5px);
        z-index: 4;
    }
    
    .robot .bolt-1 {
        top: 12px;
        left: 8px;
    }
    
    .robot .bolt-2 {
        top: 12px;
        right: 8px;
    }
    
    .robot .bolt-3 {
        bottom: 12px;
        left: 8px;
    }
    
    .robot .bolt-4 {
        bottom: 12px;
        right: 8px;
    }
    
    .robot.up {
        bottom: 20px;
        transform: rotateX(10deg);
    }
    
    .robot.whacked {
        background: linear-gradient(135deg, #555, #777, #444); /* Damaged metal look */
        transform: scale(0.9) rotateX(-10deg);
        box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.7);
        filter: brightness(0.8) contrast(1.2);
    }
    
    .robot.whacked .eye {
        background-color: #333; /* Eyes power down */
        box-shadow: 0 0 0 rgba(0, 0, 0, 0);
        animation: none;
    }
    
    .robot.whacked .antenna::after {
        background-color: #333;
        box-shadow: 0 0 0 rgba(0, 0, 0, 0);
        animation: none;
    }
    
    .robot.whacked .gear {
        animation-play-state: paused;
    }
    
    .robot.whacked .pipe-steam {
        animation: none;
        opacity: 0;
    }
    
    .robot.whacked .mouth {
        height: 2px;
        width: 15px;
        transform: translateX(-50%) rotate(10deg);
    }

    /* Dent effect when whacked */
    .robot.whacked .dent {
        position: absolute;
        width: 20px;
        height: 20px;
        background: radial-gradient(circle at center, rgba(0,0,0,0.6) 0%, transparent 70%);
        border-radius: 50%;
        top: 20px;
        left: 50%;
        transform: translate(-50%, 0);
        opacity: 0.8;
        z-index: 10;
    }

    /* Spark effect when whacked */
    .spark {
        position: absolute;
        width: 3px;
        height: 3px;
        background-color: #ffcc00;
        border-radius: 50%;
        box-shadow: 0 0 10px 2px #ffcc00;
        opacity: 0;
        pointer-events: none;
        z-index: 100;
    }
    
    /* Additional sparks with different colors for more dramatic effect */
    .spark.blue {
        background-color: #00ccff;
        box-shadow: 0 0 10px 2px #00ccff;
    }
    
    .spark.white {
        background-color: #ffffff;
        box-shadow: 0 0 10px 2px #ffffff;
    }

    .key-hint {
        position: absolute;
        bottom: 8px;
        font-size: 0.8rem;
        font-weight: 600;
        color: var(--text-secondary);
        background-color: rgba(0, 0, 0, 0.3);
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        z-index: 3;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .instructions {
        text-align: center;
        font-size: 0.9rem;
        color: var(--text-secondary);
        padding: 15px;
        background-color: var(--bg-tertiary);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.05);
        line-height: 1.5;
    }

    .active-hole {
        box-shadow: 0 0 0 2px var(--accent-primary), inset 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .active-key {
        color: var(--text-primary);
        background-color: var(--accent-primary);
        border-color: var(--accent-primary);
    }

    .streak-bonus {
        animation: pulse 0.5s;
        color: var(--accent-secondary);
    }

    .streak-reset {
        animation: shake 0.5s;
        color: var(--error);
    }

    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }

    @keyframes shake {
        0% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        50% { transform: translateX(5px); }
        75% { transform: translateX(-5px); }
        100% { transform: translateX(0); }
    }

    .hexagon-bg {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        z-index: -1;
        opacity: 0.03;
        background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0l25.98 15v30L30 60 4.02 45V15L30 0z' fill='%23ffffff' fill-opacity='1' fill-rule='evenodd'/%3E%3C/svg%3E");
        background-size: 60px 60px;
    }

    @media (max-width: 600px) {
        .game-board {
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 15px;
            transform: perspective(1000px) rotateX(3deg);
        }
        
        .hole {
            height: 100px;
        }
        
        .robot {
            width: 60px;
            height: 60px;
        }

        .stats-container {
            grid-template-columns: repeat(3, 1fr);
        }
        
        .timer-value {
            font-size: 2.8rem;
        }
    }

    @media (max-width: 400px) {
        .stats-container {
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .stat-value {
            font-size: 1.5rem;
        }
        
        .timer-value {
            font-size: 2.5rem;
        }
    }

    .countdown {
        font-family: 'Space Grotesk', sans-serif;
        font-size: 5rem;
        font-weight: 700;
        color: var(--accent-primary);
        transition: all 0.3s ease;
        text-shadow: 0 0 15px rgba(255, 58, 58, 0.5);
    }

    .robot-glow {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 12px;
        box-shadow: 0 0 15px 5px var(--accent-primary);
        opacity: 0;
        animation: glow-pulse 1.5s infinite alternate;
        pointer-events: none;
    }
    
    .robot-glow.success {
        box-shadow: 0 0 15px 5px var(--success);
    }

    @keyframes glow-pulse {
        0% { opacity: 0.3; }
        100% { opacity: 0.7; }
    }

    .wrong-hole {
        background-color: rgba(255, 82, 82, 0.3) !important;
    }

    .game-notification {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Space Grotesk', sans-serif;
        padding: 15px 25px;
        background-color: var(--bg-tertiary);
        border-radius: 8px;
        z-index: 9999;
        animation: notification-appear 0.3s;
        border: 1px solid rgba(255, 255, 255, 0.1);
        text-align: center;
        min-width: 200px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        pointer-events: none;
    }
    
    .notification-main {
        font-size: 1.8rem;
        font-weight: 700;
        margin-bottom: 8px;
        line-height: 1.2;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .notification-secondary {
        font-size: 1rem;
        color: var(--text-secondary);
        font-weight: 500;
        opacity: 0.8;
        text-transform: uppercase;
        letter-spacing: 1px;
        padding-top: 4px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    @keyframes notification-appear {
        0% { 
            transform: translate(-50%, -50%) scale(0.5); 
            opacity: 0; 
        }
        100% { 
            transform: translate(-50%, -50%) scale(1); 
            opacity: 1; 
        }
    }
    
    .fade-out {
        animation: notification-fade-out 0.5s forwards;
    }
    
    @keyframes notification-fade-out {
        0% { 
            transform: translate(-50%, -50%) scale(1); 
            opacity: 1; 
        }
        100% { 
            transform: translate(-50%, -50%) scale(0.5); 
            opacity: 0; 
        }
    }

    .game-over-subtitle {
        font-size: 1rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 20px;
    }
    
    .game-stats {
        display: flex;
        justify-content: center;
        gap: 30px;
        margin-top: 10px;
    }
    
    .game-stat {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    .game-stat .stat-label {
        font-size: 0.8rem;
        color: var(--text-secondary);
        margin-bottom: 5px;
    }
    
    .game-stat .stat-value {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--text-primary);
    }

    .level-container::after {
        background: linear-gradient(90deg, #00d395, transparent);
    }

    .level-container .stat-value {
        color: #00d395;
    }

    @keyframes time-pulse {
        0%, 100% { transform: scale(1); text-shadow: 0 0 10px rgba(255, 204, 0, 0.3); }
        50% { transform: scale(1.1); text-shadow: 0 0 20px rgba(255, 204, 0, 0.6); }
    }
    
    .time-pulse {
        animation: time-pulse 0.8s infinite;
    }
    
    .time-warning {
        background: linear-gradient(to bottom, var(--bg-tertiary), rgba(255, 184, 0, 0.2));
        border-color: rgba(255, 0, 0, 0.4) !important;
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.2);
    }

    .playing .game-board {
        animation: slight-tilt 8s infinite alternate;
    }
    
    @keyframes slight-tilt {
        0% { transform: perspective(1000px) rotateX(3deg) rotateY(-2deg); }
        100% { transform: perspective(1000px) rotateX(7deg) rotateY(2deg); }
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
    }

    .pulse {
        animation: pulse 0.8s infinite;
    }

    @keyframes time-pulse {
        0%, 100% { transform: scale(1); text-shadow: 0 0 10px rgba(255, 204, 0, 0.3); }
        50% { transform: scale(1.1); text-shadow: 0 0 20px rgba(255, 204, 0, 0.6); }
    }

    .time-pulse {
        animation: time-pulse 0.8s infinite;
    }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="hexagon-bg"></div>
        <div class="header">
            <h1>WHACK-A-ROBOT</h1>
            <div class="timer-container">
                <div class="timer-display">
                    <div class="timer-label">Time</div>
                    <div id="time" class="timer-value">60</div>
            </div>
            </div>
            <div class="stats-container">
                <div class="stat-card score-container">
                    <div class="stat-label">Score</div>
                    <div id="score" class="stat-value">0</div>
                </div>
                <div class="stat-card streak-container">
                    <div class="stat-label">Streak</div>
                    <div id="streak" class="stat-value">0</div>
                </div>
                <div class="stat-card level-container">
                    <div class="stat-label">Level</div>
                    <div id="level" class="stat-value">1</div>
                </div>
            </div>
            <button id="start-button">START GAME</button>
        </div>
        <div class="game-board">
            <div class="hole" id="hole-q" data-key="Q">
                <div class="robot"></div>
                <div class="key-hint">Q</div>
            </div>
            <div class="hole" id="hole-w" data-key="W">
                <div class="robot"></div>
                <div class="key-hint">W</div>
            </div>
            <div class="hole" id="hole-e" data-key="E">
                <div class="robot"></div>
                <div class="key-hint">E</div>
            </div>
            <div class="hole" id="hole-a" data-key="A">
                <div class="robot"></div>
                <div class="key-hint">A</div>
            </div>
            <div class="hole" id="hole-s" data-key="S">
                <div class="robot"></div>
                <div class="key-hint">S</div>
            </div>
            <div class="hole" id="hole-d" data-key="D">
                <div class="robot"></div>
                <div class="key-hint">D</div>
            </div>
        </div>
        <div class="instructions">
            <p>Press the corresponding key (Q, W, E, A, S, D) when a robot appears to whack it! Build streaks for bonus time.</p>
        </div>
    </div>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Game elements
        const holes = document.querySelectorAll('.hole');
        const robots = document.querySelectorAll('.robot');
        const scoreDisplay = document.getElementById('score');
        const timeDisplay = document.getElementById('time');
        const startButton = document.getElementById('start-button');
        const streakDisplay = document.getElementById('streak');
        const gameContainer = document.querySelector('.game-container');
        
        // Game variables
        let score = 0;
        let timeLeft = 60; // Increased to 60 seconds
        let gameInterval;
        let popUpInterval;
        let activeBots = 0; // Track number of active bots
        let maxSimultaneousBots = 1; // Start with 1 bot max
        let isPlaying = false;
        let lastHole;
        let difficulty = 1.0; // Starting difficulty value
        let lastScore = 0; // Track score for difficulty increases
        let streak = 0; // Track consecutive hits
        let highestStreak = 0; // Track highest streak
        let currentLevel = 1; // Track current level
        let pointsToNextLevel = 25; // Points needed to level up
        
        // Sound effects
        const createAudio = (src) => {
            const audio = new Audio();
            audio.src = `data:audio/mp3;base64,${src}`;
            return audio;
        };
        
        // Key mapping - expanded to include more keys for additional levels
        const keyMap = {
            'KeyQ': 'hole-q',
            'KeyW': 'hole-w',
            'KeyE': 'hole-e',
            'KeyA': 'hole-a',
            'KeyS': 'hole-s',
            'KeyD': 'hole-d',
            'KeyR': 'hole-r', // Level 2
            'KeyT': 'hole-t', // Level 2
            'KeyF': 'hole-f', // Level 3
            'KeyG': 'hole-g', // Level 3
            'KeyY': 'hole-y', // Level 4
            'KeyU': 'hole-u', // Level 4
            'KeyH': 'hole-h', // Level 5
            'KeyJ': 'hole-j'  // Level 5
        };
        
        // Available keys by level
        const keysByLevel = {
            1: ['KeyQ', 'KeyW', 'KeyE', 'KeyA', 'KeyS', 'KeyD'],
            2: ['KeyQ', 'KeyW', 'KeyE', 'KeyR', 'KeyA', 'KeyS', 'KeyD', 'KeyF'],
            3: ['KeyQ', 'KeyW', 'KeyE', 'KeyR', 'KeyT', 'KeyA', 'KeyS', 'KeyD', 'KeyF', 'KeyG'],
            4: ['KeyQ', 'KeyW', 'KeyE', 'KeyR', 'KeyT', 'KeyY', 'KeyA', 'KeyS', 'KeyD', 'KeyF', 'KeyG', 'KeyH'],
            5: ['KeyQ', 'KeyW', 'KeyE', 'KeyR', 'KeyT', 'KeyY', 'KeyU', 'KeyA', 'KeyS', 'KeyD', 'KeyF', 'KeyG', 'KeyH', 'KeyJ']
        };
        
        // Initialize game
        function initGame() {
            // Reset game variables
            score = 0;
            lastScore = 0;
            timeLeft = 60; // Increased to 60 seconds
            difficulty = 1.0; // Reset difficulty to initial value
            maxSimultaneousBots = 1; // Reset to 1 bot max
            activeBots = 0; // Reset active bots counter
            streak = 0;
            highestStreak = 0;
            currentLevel = 1;
            pointsToNextLevel = 25; // Points needed to level up
            
            // Update UI
            scoreDisplay.textContent = score;
            timeDisplay.textContent = timeLeft;
            streakDisplay.textContent = streak;
            streakDisplay.classList.remove('streak-bonus', 'streak-reset');
            startButton.textContent = 'GAME IN PROGRESS';
            startButton.disabled = true;
            
            // Reset game board to level 1
            resetGameBoard();
            
            // Add playing class to container
            gameContainer.classList.add('playing');
            
            // Hide all robots initially
            document.querySelectorAll('.robot').forEach(robot => {
                robot.classList.remove('up');
                robot.classList.remove('whacked');
            });
            
            // Add start game animation - actual game will start after animation completes
            addStartGameAnimation();
            
            // Debug message
            console.log("Game initialization complete, waiting for animation to finish");
        }
        
        // Reset game board to initial state for the current level
        function resetGameBoard() {
            // Clear existing game board
            const gameBoard = document.querySelector('.game-board');
            gameBoard.innerHTML = '';
            
            // Get keys for current level
            const currentKeys = keysByLevel[currentLevel];
            
            // Calculate grid layout based on number of holes
            let columns = 3;
            if (currentKeys.length > 6) {
                columns = 4;
            }
            if (currentKeys.length > 8) {
                columns = 5;
            }
            
            const rows = Math.ceil(currentKeys.length / columns);
            
            // Update grid layout
            gameBoard.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
            gameBoard.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            
            // Create holes for current level
            currentKeys.forEach(keyCode => {
                const key = keyCode.replace('Key', '');
                const holeId = keyMap[keyCode];
                
                const hole = document.createElement('div');
                hole.className = 'hole';
                hole.id = holeId;
                hole.dataset.key = key;
                
                const robot = document.createElement('div');
                robot.className = 'robot';
                
                const keyHint = document.createElement('div');
                keyHint.className = 'key-hint';
                keyHint.textContent = key;
                
                hole.appendChild(robot);
                hole.appendChild(keyHint);
                gameBoard.appendChild(hole);
            });
            
            // Update level display
            updateLevelDisplay();
            
            // Update instructions
            updateInstructions(currentKeys);
            
            console.log(`Game board reset for level ${currentLevel} with ${currentKeys.length} holes`);
        }
        
        // Update instructions based on current level
        function updateInstructions(currentKeys) {
            const instructions = document.querySelector('.instructions p');
            const keyList = currentKeys.map(key => key.replace('Key', '')).join(', ');
            instructions.textContent = `Press the corresponding key (${keyList}) when a robot appears to whack it! Build streaks for bonus time.`;
        }
        
        // Update level display
        function updateLevelDisplay() {
            // Simply update the level number
            const levelDisplay = document.getElementById('level');
            levelDisplay.textContent = currentLevel;
        }
        
        // Level up function
        function levelUp() {
            // Increase level
            currentLevel = Math.min(currentLevel + 1, 5); // Max level 5
            
            // Reset difficulty but start slightly higher for each level
            difficulty = 1.0 + (currentLevel * 0.2); // Difficulty scales with level
            
            // Also increase max simultaneous bots with level
            maxSimultaneousBots = Math.min(1 + Math.floor(currentLevel/2), 3); // Max 3 bots at once
            
            // Add time bonus for leveling up (reduced to 15 seconds)
            timeLeft += 15;
            timeDisplay.textContent = timeLeft;
            
            // Add level up animation to game container
            gameContainer.classList.add('level-up');
            setTimeout(() => {
                gameContainer.classList.remove('level-up');
            }, 1000);
            
            // Reset game board for new level
            resetGameBoard();
            
            // Show level up notification with updated time bonus
            showNotification(`LEVEL UP!`, '#00d395', '+15s TIME BONUS');
            
            // Create level up particles
            const rect = document.getElementById('level').getBoundingClientRect();
            createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, '#00d395');
            
            // Add animation to level display
            const levelDisplay = document.getElementById('level');
            levelDisplay.classList.add('level-up-animation');
            setTimeout(() => {
                levelDisplay.classList.remove('level-up-animation');
            }, 1000);
            
            console.log(`Leveled up to ${currentLevel}! +15 seconds bonus (Total: ${timeLeft}s)`);
        }
        
        // Add start game animation
        function addStartGameAnimation() {
            const overlay = document.createElement('div');
            overlay.className = 'game-start-overlay';
            overlay.innerHTML = '<div class="countdown">3</div>';
            gameContainer.appendChild(overlay);
            
            let count = 3;
            const countdownEl = overlay.querySelector('.countdown');
            
            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownEl.textContent = count;
                    countdownEl.classList.add('pulse-animation');
                    setTimeout(() => countdownEl.classList.remove('pulse-animation'), 500);
                } else {
                    clearInterval(countInterval);
                    countdownEl.textContent = 'GO!';
                    countdownEl.classList.add('pulse-animation');
                    
                    setTimeout(() => {
                        overlay.remove();
                        
                        // NOW start the actual game after animation completes
                        startGameAfterAnimation();
                    }, 600);
                }
            }, 1000);
        }
        
        // Function to start the game after animation completes
        function startGameAfterAnimation() {
            // Set game as playing
            isPlaying = true;
            
            // Start game intervals
            gameInterval = setInterval(countdown, 1000);
            
            // Start with a longer delay between robots
            scheduleNextRobot();
            
            console.log("Animation complete, game started with difficulty:", difficulty);
        }
        
        // Schedule the next robot appearance
        function scheduleNextRobot() {
            if (!isPlaying) return;
            
            // Only spawn new robots if we're under the max simultaneous limit
            if (activeBots >= maxSimultaneousBots) {
                return;
            }
            
            // Calculate delays based on current difficulty and score
            // More gradual scaling with score and level
            const levelFactor = 1 / Math.pow(currentLevel, 0.35);
            const scoreMultiplier = 1 + (score * 0.05 * levelFactor);
            const minDelay = Math.max(180, 1600 - (difficulty * 200 * levelFactor) - (score * 10 * levelFactor));
            const maxDelay = Math.max(350, 2000 - (difficulty * 240 * levelFactor) - (score * 15 * levelFactor));
            
            const delay = getRandomTime(minDelay, maxDelay);
            
            // Debug
            console.log(`Next robot in ${delay}ms (Difficulty: ${difficulty.toFixed(2)}, Level: ${currentLevel}, Score: ${score}, Active bots: ${activeBots}/${maxSimultaneousBots})`);
            
            // Track active bots
            activeBots++;
            
            popUpInterval = setTimeout(() => {
                popRobot();
                
                // Schedule another bot if we still can
                if (activeBots < maxSimultaneousBots) {
                    scheduleNextRobot();
                }
            }, delay);
        }
        
        // Countdown timer
        function countdown() {
            timeLeft--;
            timeDisplay.textContent = timeLeft;
            
            // Visual feedback for low time
            if (timeLeft <= 10) {
                timeDisplay.parentElement.classList.add('time-warning');
                timeDisplay.style.color = timeLeft <= 5 ? 'var(--error)' : 'var(--warning)';
                
                // Add pulsing animation when time is low
                if (!timeDisplay.classList.contains('time-pulse')) {
                    timeDisplay.classList.add('time-pulse');
                }
                
                // Increase intensity of pulse as time decreases
                const pulseIntensity = Math.max(0.5, (10 - timeLeft) / 10);
                timeDisplay.style.animation = `time-pulse 0.${Math.floor(10 - timeLeft * pulseIntensity)}s infinite`;
            } else {
                timeDisplay.parentElement.classList.remove('time-warning');
                timeDisplay.style.color = 'var(--accent-secondary)';
                timeDisplay.classList.remove('time-pulse');
                timeDisplay.style.animation = '';
            }
            
            if (timeLeft <= 0) {
                endGame();
            }
        }
        
        // End game
        function endGame() {
            clearInterval(gameInterval);
            clearTimeout(popUpInterval);
            isPlaying = false;
            startButton.textContent = 'PLAY AGAIN';
            startButton.disabled = false;
            
            // Remove playing class
            gameContainer.classList.remove('playing');
            
            // Hide all robots
            document.querySelectorAll('.robot').forEach(robot => {
                robot.classList.remove('up');
            });
            
            // Show game over overlay
            showGameOverOverlay();
        }
        
        // Show game over overlay
        function showGameOverOverlay() {
            const overlay = document.createElement('div');
            overlay.className = 'game-over-overlay';
            
            let message = '';
            let scoreClass = '';
            
            if (score >= 30) {
                message = 'LEGENDARY!';
                scoreClass = 'score-legendary';
            } else if (score >= 20) {
                message = 'AMAZING!';
                scoreClass = 'score-amazing';
            } else if (score >= 10) {
                message = 'GREAT JOB!';
                scoreClass = 'score-great';
            } else {
                message = 'GAME OVER';
                scoreClass = 'score-normal';
            }
            
            overlay.innerHTML = `
                <div class="game-over-content">
                    <div class="game-over-title">${message}</div>
                    <div class="final-score ${scoreClass}">${score}</div>
                    <div class="game-over-subtitle">FINAL SCORE</div>
                    <div class="game-stats">
                        <div class="game-stat">
                            <span class="stat-label">LEVEL</span>
                            <span class="stat-value">${currentLevel}</span>
                        </div>
                        <div class="game-stat">
                            <span class="stat-label">HIGHEST STREAK</span>
                            <span class="stat-value">${highestStreak}</span>
                        </div>
                    </div>
                </div>
            `;
            
            gameContainer.appendChild(overlay);
            
            // Add click event to remove overlay
            overlay.addEventListener('click', () => {
                overlay.remove();
            });
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.remove();
                }
            }, 5000);
        }
        
        // Get random time for robot to pop up
        function getRandomTime(min, max) {
            return Math.floor(Math.random() * (max - min) + min);
        }
        
        // Get random hole
        function getRandomHole() {
            // Get only holes for the current level
            const currentHoles = document.querySelectorAll('.hole');
            const index = Math.floor(Math.random() * currentHoles.length);
            const hole = currentHoles[index];
            
            // Avoid same hole twice in a row
            if (hole === lastHole) {
                return getRandomHole();
            }
            
            lastHole = hole;
            return hole;
        }
        
        // Pop robot up from a random hole
        function popRobot() {
            if (!isPlaying) return;
            
            // Robot stays up for more time as difficulty increases and score increases
            // More gradual scaling with level and score
            const levelFactor = 1 / Math.pow(currentLevel, 0.35);
            const scoreMultiplier = 1 + (score * 0.05 * levelFactor);
            const minTime = Math.max(400, 1600 - (difficulty * 140 * levelFactor) - (score * 12 * levelFactor));
            const maxTime = Math.max(700, 2000 - (difficulty * 180 * levelFactor) - (score * 18 * levelFactor));
            
            const time = getRandomTime(minTime, maxTime);
            const hole = getRandomHole();
            const robot = hole.querySelector('.robot');
            const keyHint = hole.querySelector('.key-hint');
            
            // Debug
            console.log(`Robot up for ${time}ms (Difficulty: ${difficulty.toFixed(2)}, Level: ${currentLevel}, Score: ${score}, Active bots: ${activeBots}/${maxSimultaneousBots})`);
            
            // Add steampunk elements to robot
            if (!robot.querySelector('.head')) {
                // Add humanoid robot structure
                // Head and face
                const head = document.createElement('div');
                head.className = 'head';
                robot.appendChild(head);
                
                const face = document.createElement('div');
                face.className = 'face';
                head.appendChild(face);
                
                const eyes = document.createElement('div');
                eyes.className = 'eyes';
                face.appendChild(eyes);
                
                // Create two eyes
                const leftEye = document.createElement('div');
                leftEye.className = 'eye';
                eyes.appendChild(leftEye);
                
                const rightEye = document.createElement('div');
                rightEye.className = 'eye';
                eyes.appendChild(rightEye);
                
                const mouth = document.createElement('div');
                mouth.className = 'mouth';
                face.appendChild(mouth);
                
                // Body parts
                const body = document.createElement('div');
                body.className = 'body';
                robot.appendChild(body);
                
                const antenna = document.createElement('div');
                antenna.className = 'antenna';
                head.appendChild(antenna);
                
                // Add gears
                const gear1 = document.createElement('div');
                gear1.className = 'gear gear-1';
                robot.appendChild(gear1);
                
                const gear2 = document.createElement('div');
                gear2.className = 'gear gear-2';
                robot.appendChild(gear2);
                
                // Add pipe with steam
                const pipe = document.createElement('div');
                pipe.className = 'pipe';
                robot.appendChild(pipe);
                
                const steam = document.createElement('div');
                steam.className = 'pipe-steam';
                robot.appendChild(steam);
                
                // Add bolts
                for (let i = 1; i <= 4; i++) {
                    const bolt = document.createElement('div');
                    bolt.className = `bolt bolt-${i}`;
                    robot.appendChild(bolt);
                }
            }
            
            // Add active classes
            hole.classList.add('active-hole');
            keyHint.classList.add('active-key');
            robot.classList.add('up');
            
            // Add glowing effect to active robot
            addGlowEffect(robot);
            
            // Set timeout to hide robot
            setTimeout(() => {
                if (isPlaying) {
                    robot.classList.remove('up');
                    robot.classList.remove('whacked');
                    hole.classList.remove('active-hole');
                    keyHint.classList.remove('active-key');
                    
                    // Remove glow effect
                    removeGlowEffect(robot);
                    
                    // Decrease active bots counter
                    activeBots--;
                    
                    // Schedule next robot if needed
                    scheduleNextRobot();
                }
            }, time);
        }
        
        // Add glow effect to robot
        function addGlowEffect(robot) {
            const glow = document.createElement('div');
            glow.className = 'robot-glow';
            robot.appendChild(glow);
        }
        
        // Remove glow effect from robot
        function removeGlowEffect(robot) {
            const glow = robot.querySelector('.robot-glow');
            if (glow) {
                glow.remove();
            }
        }
        
        // Create particle effect
        function createParticles(x, y, color) {
            const particleCount = 15;
            const container = document.createElement('div');
            container.style.position = 'absolute';
            container.style.left = `${x}px`;
            container.style.top = `${y}px`;
            container.style.pointerEvents = 'none';
            container.style.zIndex = '1000';
            document.body.appendChild(container);
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.width = `${Math.random() * 8 + 4}px`;
                particle.style.height = particle.style.width;
                particle.style.backgroundColor = color;
                particle.style.borderRadius = '50%';
                particle.style.opacity = '0.8';
                particle.style.transform = 'translate(-50%, -50%)';
                
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 100 + 50;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                container.appendChild(particle);
                
                let posX = 0;
                let posY = 0;
                let startTime = performance.now();
                
                function animate(time) {
                    const elapsed = time - startTime;
                    const duration = 800; // ms
                    
                    if (elapsed < duration) {
                        const progress = elapsed / duration;
                        posX = vx * progress;
                        posY = vy * progress - 0.5 * 980 * progress * progress; // Add gravity
                        
                        particle.style.transform = `translate(${posX}px, ${posY}px) scale(${1 - progress})`;
                        particle.style.opacity = 1 - progress;
                        
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                        if (container.children.length === 0) {
                            container.remove();
                        }
                    }
                }
                
                requestAnimationFrame(animate);
            }
        }
        
        // Create spark effect
        function createSparks(robot) {
            const rect = robot.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Create dent effect
            const dent = document.createElement('div');
            dent.className = 'dent';
            robot.appendChild(dent);
            
            // Create sparks with different colors
            const sparkColors = ['', 'blue', 'white']; // '' is default yellow
            
            // Create more sparks for a more dramatic effect
            for (let i = 0; i < 12; i++) {
                const spark = document.createElement('div');
                spark.className = 'spark ' + sparkColors[Math.floor(Math.random() * sparkColors.length)];
                document.body.appendChild(spark);
                
                // Random position around the robot
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 40 + 20;
                const startX = centerX + Math.cos(angle) * (rect.width / 3);
                const startY = centerY + Math.sin(angle) * (rect.height / 3);
                
                // Random trajectory
                const endX = startX + Math.cos(angle) * distance;
                const endY = startY + Math.sin(angle) * distance;
                
                // Random size for variety
                const size = Math.random() * 3 + 2;
                spark.style.width = `${size}px`;
                spark.style.height = `${size}px`;
                
                // Set initial position
                spark.style.left = `${startX}px`;
                spark.style.top = `${startY}px`;
                
                // Animate the spark
                const duration = Math.random() * 400 + 200;
                spark.style.transition = `all ${duration}ms ease-out`;
                
                // Start animation
                setTimeout(() => {
                    spark.style.opacity = '1';
                    spark.style.left = `${endX}px`;
                    spark.style.top = `${endY}px`;
                    
                    // Remove after animation
                    setTimeout(() => {
                        spark.remove();
                    }, duration);
                }, Math.random() * 50); // Staggered start for more natural effect
            }
        }
        
        // Handle streak bonus
        function handleStreakBonus() {
            streak++;
            streakDisplay.textContent = streak;
            
            // Update highest streak
            if (streak > highestStreak) {
                highestStreak = streak;
            }
            
            // Check if streak is a multiple of 5
            if (streak > 0 && streak % 5 === 0) {
                // Add 5 seconds bonus for every 5 consecutive hits
                timeLeft += 5;
                timeDisplay.textContent = timeLeft;
                
                // Add 5 extra points for every 5 consecutive hits
                score += 5;
                scoreDisplay.textContent = score;
                
                // Visual feedback for streak bonus
                streakDisplay.classList.add('streak-bonus');
                setTimeout(() => {
                    streakDisplay.classList.remove('streak-bonus');
                }, 500);
                
                // Create yellow particles for streak bonus
                const rect = streakDisplay.getBoundingClientRect();
                createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, 'var(--accent-secondary)');
                
                // Create red particles for score bonus
                const scoreRect = scoreDisplay.getBoundingClientRect();
                createParticles(scoreRect.left + scoreRect.width / 2, scoreRect.top + scoreRect.height / 2, 'var(--accent-primary)');
                
                // Show streak bonus notification with separate time bonus
                showNotification(`+5 POINTS BONUS!`, 'var(--accent-secondary)', '+5s TIME');
                
                console.log(`Streak bonus! +5 seconds and +5 points for ${streak} consecutive hits (Total: ${timeLeft}s, Score: ${score})`);
            }
        }
        
        // Notification queue system
        let notificationQueue = [];
        let isProcessingQueue = false;
        let activeNotifications = 0;
        const MAX_ACTIVE_NOTIFICATIONS = 3;
        const NOTIFICATION_SPACING = 80; // Vertical spacing between notifications
        
        // Show notification
        function showNotification(text, color, secondaryText = null) {
            notificationQueue.push({ text, color, secondaryText });
            processNotificationQueue();
        }
        
        // Process notification queue
        function processNotificationQueue() {
            if (isProcessingQueue || notificationQueue.length === 0) return;
            
            isProcessingQueue = true;
            const notification = notificationQueue.shift();
            
            if (activeNotifications >= MAX_ACTIVE_NOTIFICATIONS) {
                setTimeout(() => {
                    processNotificationQueue();
                }, 500);
                return;
            }
            
            const notificationElement = document.createElement('div');
            notificationElement.className = 'game-notification';
            
            const mainText = document.createElement('div');
            mainText.className = 'notification-main';
            mainText.textContent = notification.text;
            mainText.style.color = notification.color;
            
            notificationElement.appendChild(mainText);
            
            if (notification.secondaryText) {
                const secondaryLine = document.createElement('div');
                secondaryLine.className = 'notification-secondary';
                secondaryLine.textContent = notification.secondaryText;
                notificationElement.appendChild(secondaryLine);
            }
            
            // Calculate position based on number of active notifications
            const baseTop = 50; // Center vertically
            const offset = (activeNotifications * NOTIFICATION_SPACING);
            notificationElement.style.top = `${baseTop + offset}%`;
            
            // Append to game board instead of body
            const gameBoard = document.querySelector('.game-board');
            gameBoard.appendChild(notificationElement);
            activeNotifications++;
            
            // Animate and remove
            setTimeout(() => {
                notificationElement.classList.add('fade-out');
                setTimeout(() => {
                    notificationElement.remove();
                    activeNotifications--;
                    isProcessingQueue = false;
                    processNotificationQueue();
                }, 500);
            }, 2000);
        }
        
        // Handle streak reset
        function handleStreakReset() {
            // Visual feedback for streak reset
            streakDisplay.classList.add('streak-reset');
            setTimeout(() => {
                streakDisplay.classList.remove('streak-reset');
            }, 500);
            
            console.log(`Streak reset! Lost streak of ${streak}`);
            
            // Reset streak counter
            streak = 0;
            streakDisplay.textContent = streak;
            
            // Deduct 1 second for missing
            timeLeft = Math.max(1, timeLeft - 1); // Ensure time doesn't go below 1
            timeDisplay.textContent = timeLeft;
            
            // Show streak reset notification with separate time deduction
            showNotification(`STREAK RESET!`, 'var(--error)', '-1s TIME');
        }
        
        // Handle keyboard input
        function handleKeyPress(e) {
            if (!isPlaying) return;
            
            const keyCode = e.code;
            // Only process keys that are active in the current level
            if (keyMap[keyCode] && keysByLevel[currentLevel].includes(keyCode)) {
                const holeId = keyMap[keyCode];
                const hole = document.getElementById(holeId);
                if (!hole) return; // Skip if hole doesn't exist
                
                const robot = hole.querySelector('.robot');
                
                // Check if robot is up and not already whacked
                if (robot.classList.contains('up') && !robot.classList.contains('whacked')) {
                    // Successful whack
                    robot.classList.add('whacked');
                    score++;
                    scoreDisplay.textContent = score;
                    
                    // Create GREEN particles at whack location for successful hit
                    const rect = robot.getBoundingClientRect();
                    createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, 'var(--success)');
                    
                    // Add spark effect for metallic impact
                    createSparks(robot);
                    
                    // Add success glow effect
                    const glow = robot.querySelector('.robot-glow');
                    if (glow) {
                        glow.classList.add('success');
                    } else {
                        // If no glow exists, create one with success class
                        const successGlow = document.createElement('div');
                        successGlow.className = 'robot-glow success';
                        robot.appendChild(successGlow);
                    }
                    
                    // Increment streak and check for streak bonus
                    handleStreakBonus();
                    
                    // Check if score has increased by 2 points (every 2 points)
                    if (Math.floor(score / 2) > Math.floor(lastScore / 2)) {
                        // Increase difficulty every 2 points
                        difficulty += 0.3; // Steeper difficulty increase
                        
                        // Check if we should increase max simultaneous bots
                        if (difficulty > 3 && maxSimultaneousBots < 2) {
                            maxSimultaneousBots = 2;
                        } else if (difficulty > 5 && maxSimultaneousBots < 3) {
                            maxSimultaneousBots = 3;
                        }
                        
                        console.log(`Difficulty increased to ${difficulty.toFixed(2)} (Level ${currentLevel}, Max Bots: ${maxSimultaneousBots})`);
                        
                        // Try to schedule another bot if we can have more
                        if (activeBots < maxSimultaneousBots) {
                            scheduleNextRobot();
                        }
                    }
                    
                    // Check for level up (every 25 points)
                    if (score >= pointsToNextLevel && currentLevel < 5) {
                        levelUp();
                        pointsToNextLevel += 25;
                    }
                    
                    // Update lastScore
                    lastScore = score;
                } else if (!robot.classList.contains('up')) {
                    // Wrong hole penalty - reset streak and deduct time
                    handleStreakReset();
                    
                    // Visual feedback for wrong hole
                    hole.classList.add('wrong-hole');
                    setTimeout(() => {
                        hole.classList.remove('wrong-hole');
                    }, 200);
                    
                    // Create red particles
                    const rect = hole.getBoundingClientRect();
                    createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, 'var(--error)');
                    
                    console.log(`Wrong hole! -1 second penalty (Time left: ${timeLeft}s)`);
                }
            }
        }
        
        // Event listeners
        startButton.addEventListener('click', initGame);
        document.addEventListener('keydown', handleKeyPress);
        
        // Visual feedback for key presses
        document.addEventListener('keydown', (e) => {
            const keyCode = e.code;
            if (keyMap[keyCode]) {
                const holeId = keyMap[keyCode];
                const hole = document.getElementById(holeId);
                hole.style.transform = 'scale(0.95)';
                
                setTimeout(() => {
                    hole.style.transform = 'scale(1)';
                }, 100);
            }
        });
        
        // Add CSS for additional animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.05); }
            }
            
            .pulse {
                animation: pulse 0.8s infinite;
            }
            
            @keyframes time-pulse {
                0%, 100% { transform: scale(1); text-shadow: 0 0 10px rgba(255, 204, 0, 0.3); }
                50% { transform: scale(1.1); text-shadow: 0 0 20px rgba(255, 204, 0, 0.6); }
            }
            
            .time-pulse {
                animation: time-pulse 0.8s infinite;
            }
            
            .time-warning {
                background: linear-gradient(to bottom, var(--bg-tertiary), rgba(255, 184, 0, 0.2));
                border-color: rgba(255, 0, 0, 0.4) !important;
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.2);
            }
            
            .playing .game-board {
                animation: slight-tilt 8s infinite alternate;
            }
            
            @keyframes slight-tilt {
                0% { transform: perspective(1000px) rotateX(3deg) rotateY(-2deg); }
                100% { transform: perspective(1000px) rotateX(7deg) rotateY(2deg); }
            }
            
            .robot-glow {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                border-radius: 12px;
                box-shadow: 0 0 15px 5px var(--accent-primary);
                opacity: 0;
                animation: glow-pulse 1.5s infinite alternate;
                pointer-events: none;
            }
            
            .robot-glow.success {
                box-shadow: 0 0 15px 5px var(--success);
            }
            
            .wrong-hole {
                background-color: rgba(255, 82, 82, 0.3) !important;
            }
            
            .game-start-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(10, 11, 14, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 100;
                backdrop-filter: blur(5px);
            }
            
            .pulse-animation {
                animation: pulse-once 0.5s;
            }
            
            @keyframes pulse-once {
                0% { transform: scale(1); }
                50% { transform: scale(1.5); }
                100% { transform: scale(1); }
            }
            
            .game-over-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(10, 11, 14, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 100;
                backdrop-filter: blur(5px);
                cursor: pointer;
            }
            
            .game-over-content {
                text-align: center;
            }
            
            .game-over-title {
                font-family: 'Space Grotesk', sans-serif;
                font-size: 2.5rem;
                font-weight: 700;
                color: var(--text-primary);
                margin-bottom: 20px;
            }
            
            .final-score {
                font-family: 'Space Grotesk', sans-serif;
                font-size: 5rem;
                font-weight: 700;
                margin-bottom: 10px;
            }
            
            .score-legendary {
                color: var(--accent-secondary);
                text-shadow: 0 0 10px var(--accent-secondary);
            }
            
            .score-amazing {
                color: var(--accent-primary);
                text-shadow: 0 0 10px var(--accent-primary);
            }
            
            .score-great {
                color: var(--accent-tertiary);
                text-shadow: 0 0 10px var(--accent-tertiary);
            }
            
            .score-normal {
                color: var(--text-primary);
            }
            
            .game-over-subtitle {
                font-size: 1rem;
                color: var(--text-secondary);
                text-transform: uppercase;
                letter-spacing: 2px;
                margin-bottom: 20px;
            }
            
            .game-stats {
                display: flex;
                justify-content: center;
                gap: 30px;
                margin-top: 10px;
            }
            
            .game-stat {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            .game-stat .stat-label {
                font-size: 0.8rem;
                color: var(--text-secondary);
                margin-bottom: 5px;
            }
            
            .game-stat .stat-value {
                font-size: 1.5rem;
                font-weight: 700;
                color: var(--text-primary);
            }
            
            .game-notification {
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                font-family: 'Space Grotesk', sans-serif;
                padding: 15px 25px;
                background-color: var(--bg-tertiary);
                border-radius: 8px;
                z-index: 9999;
                animation: notification-appear 0.3s;
                border: 1px solid rgba(255, 255, 255, 0.1);
                text-align: center;
                min-width: 200px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                pointer-events: none;
            }
            
            .notification-main {
                font-size: 1.8rem;
                font-weight: 700;
                margin-bottom: 8px;
                line-height: 1.2;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            }
            
            .notification-secondary {
                font-size: 1rem;
                color: var(--text-secondary);
                font-weight: 500;
                opacity: 0.8;
                text-transform: uppercase;
                letter-spacing: 1px;
                padding-top: 4px;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            @keyframes notification-appear {
                0% { 
                    transform: translate(-50%, -50%) scale(0.5); 
                    opacity: 0; 
                }
                100% { 
                    transform: translate(-50%, -50%) scale(1); 
                    opacity: 1; 
                }
            }
            
            .fade-out {
                animation: notification-fade-out 0.5s forwards;
            }
            
            @keyframes notification-fade-out {
                0% { 
                    transform: translate(-50%, -50%) scale(1); 
                    opacity: 1; 
                }
                100% { 
                    transform: translate(-50%, -50%) scale(0.5); 
                    opacity: 0; 
                }
            }
        `;
        document.head.appendChild(style);
    });
    </script>
</body>
</html> 